---
output: html_document
---

## NGINX & Docker-Compose

<strong>NGINX</strong> - An open source web server and reverse proxy technology used for hosting websites and applications

<strong>Docker-Compose</strong> - A technology for enabling docker containers to communicate to each other

In this post, I will go over steps of how to create an encrypt (https) traffic that allows users to interact with the Xposome application that is published through a docker container. To achieve that, we need both NGINX and docker-compose.

Here are seven steps to set-up NGINX and docker-compose:

1.	Install docker-compose
2.	Build a NGINX image from Docker Hub without the need of installing NGINX software
3.	Dockerize the Xposome application locally or pull the image from Docker Hub
4.	Set up NGINX configuration files 
5.	Create a YAML file for docker-compose (i.e. docker-compose.yml)
6.	Run the docker-compose.yml file
7.	Check to see if the application is running on https

<br>

#### Step 1: Install docker-compose

Check out how to install Docker-compose <a href="https://docs.docker.com/compose/install/">here</a>

To check if docker-compose is installed, 

    docker-compose --version

#### Step 2: Build a docker image for NGINX

An image for NGINX can be found at <a href="https://hub.docker.com/_/nginx">Docker Hub</a>. You can pull this image without the need of installing the NGINX software locally.

    docker pull nginx:latest 

To check if the image is built successfully 

    docker images

Also see this <a href="https://hub.docker.com/_/nginx">link</a> on how to use the NGINX image

#### Step 3: Dockerize the Xposome application locally or pull the image from Docker Hub

You can check out this step on my previous post <a href='#dockerize'>here</a> for more details

#### Step 4: Set-up NGINX configuration files

Once the images for NGINX and Xposome application are build successfully, we can start setting up the NGINX configuration files. There are two configuration files for NGINX, <span class="highlight-text">nginx.conf</span> and <span class="highlight-text">default.conf.template files</span>. 

The nginx.conf file contains the standard configuration for NGINX. Unless you know how to add directives to a configuration file, otherwise, I do not recommend making any changes to this file. 

For example, one of the directives that we used on our web portal is to maximize a file uploading size from our users. This directive is useful as it helped us avoided the problems of importing some gene expression datasets that far exceeded the limit of 1MB file uploads on NGINX.

The default.conf.template file contains HTTP configuration that allows NGINX to direct any encrypt (https) or unencrypt (http) traffics to an application that is published on a specified port on the host machine.  

How NGINX talks to Docker

    With NGINX,
    nginx → listens on → port 80 (http) and 443 (https) 

    With Docker,
    Docker → listens on → port 80/443/8080/3838/8000/… 

    With SHINY
    Shiny → listens on localhost → port 3838/8787/4848/… 

In other words, when we run a docker container, we basically expose our application through a port that is viewable on a Shiny's localhost (for example: port 3838). Docker listens to this port and reroutes the application to a specified port on the host machine (for example: port 7856). Therefore, when we navigate to port 7856 on the host domain (for example http://[domain_name/ip address]:7856), we will see that the shiny app is hosted there. 

Nevertheless, we probably do not want to direct our users to an application through a port link. Thus, we can use NGINX configuration files to create an alias location for the application (for example https://[domain_name/ip address]/Xposome/). Hence, when a user is navigated to that specified address on the host domain, NGINX will transfer that traffic to the port e.g. 7856 of where the application was originally published on. Furthermore, NGINX will encrypt that traffic with a https protocol. As a result, NGINX is served as a reverse proxy for hosting our applications.

Here is a snapshot of how the http configuration file looks like:

<a href="www/nginx-conf.png" target="blank"><img class="img-box" src="www/nginx-conf.png"></a>


#### Step 5: Create a docker-compose.yml file

Once we had configured NGINX as a reverse proxy for our application, we can create a docker-compose.yml file that comprises of all of the containers that we want to communicate with NGINX container.

To enable communication between containers, in the docker-compose file, we must create a service to run the NGINX container and a service to run the Xposome container. Under each service, we need to specify a list of instructions of how a container can be built, for instance, what image is used to build the container, what do we want to name the container, what port is used to expose the shiny app to Docker, and what port is used to publish the app on the host machine, etc.

After we had defined all of the key components of how the containers can be built, one last step is to confirm the host port on the docker-compose.yml file matches the port that NGINX redirects the encrypt traffics to the application on HTTP configuration file.

Here is a snapshot of the docker-compose.yml file:

<a href="www/docker-compose.png" target="blank"><img class="img-box" src="www/docker-compose.png"></a>


#### Step 6: Run the docker-compose file

After we had the docker-compose file and NGINX configuration files all set up, we can cd to where docker-compose.yml is located and run the following command to fire up all the containers that were defined in the docker-compose file.

    docker-compose up -d
    
    -d is used to run docker compose in detach mode

#### Step 7: Check to make sure the application is running on https 

Navigate to the alias domain for the application (for example https://montilab.bu.edu/Xposome/) and see if the application is indeed hosted there.

<br><br>





